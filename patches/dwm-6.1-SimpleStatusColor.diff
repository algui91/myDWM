diff --git a/config.def.h b/config.def.h
index 875885b..f466b1d 100644
--- a/config.def.h
+++ b/config.def.h
@@ -12,6 +12,12 @@ static const unsigned int borderpx  = 1;        /* border pixel of windows */
 static const unsigned int snap      = 32;       /* snap pixel */
 static const Bool showbar           = True;     /* False means no bar */
 static const Bool topbar            = True;     /* False means bottom bar */
+static const unsigned long colors[] = {
+    0xbbbbbb,   // \x01
+    0xdb6794,   // \x02
+    0xef9c3a,   // \x03
+    0xa4bc74,   // \x04
+};
 
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
diff --git a/drw.c b/drw.c
index b130405..0811d93 100644
--- a/drw.c
+++ b/drw.c
@@ -7,6 +7,8 @@
 #include "drw.h"
 #include "util.h"
 
+#define TEXTW(X)                (drw_font_getexts_width(drw->font, X, strlen(X)) + drw->font->h)
+
 Drw *
 drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h) {
 	Drw *drw = (Drw *)calloc(1, sizeof(Drw));
@@ -140,6 +142,43 @@ drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int
 }
 
 void
+drw_colored_st(Drw *drw, int x, int y, unsigned int w, unsigned int h, char text[][256], const unsigned long *color, const char *ptext) {
+  char buf[256];
+  int i, tx, ty, th, len, olen;
+  Extnts tex;
+
+  if(!drw || !drw->scheme)
+    return;
+  XSetForeground(drw->dpy, drw->gc, drw->scheme->bg->rgb);
+  XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+  if(!text || !drw->font)
+    return;
+  olen = strlen(ptext);
+  drw_font_getexts(drw->font, ptext, olen, &tex);
+  th = drw->font->ascent + drw->font->descent;
+  ty = y + (h / 2) - (th / 2) + drw->font->ascent;
+  tx = x + (h / 2);
+  /* shorten text if necessary */
+  for(len = MIN(olen, sizeof buf); len && (tex.w > w - tex.h || w < tex.h); len--)
+    drw_font_getexts(drw->font, ptext, len, &tex);
+  if(!len)
+    return;
+  memcpy(buf, ptext, len);
+  if(len < olen)
+    for(i = len; i && i > len - 3; buf[--i] = '.');
+
+  for (int k = 0; color[k]; k++) {
+    XSetForeground(drw->dpy, drw->gc, color[k]);
+    if (drw->font->set)
+      XmbDrawString(drw->dpy, drw->drawable, drw->font->set, drw->gc, tx, ty,
+                    text[k], strlen(text[k]));
+    else
+      XDrawString(drw->dpy, drw->drawable, drw->gc, tx, ty, text[k], strlen(text[k]));
+    tx += TEXTW(text[k]) - TEXTW("\x0");
+  }
+}
+
+void
 drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert) {
 	char buf[256];
 	int i, tx, ty, th, len, olen;
diff --git a/drw.h b/drw.h
index a5f34e0..043893f 100644
--- a/drw.h
+++ b/drw.h
@@ -64,6 +64,7 @@ void drw_setscheme(Drw *drw, ClrScheme *scheme);
 /* Drawing functions */
 void drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int empty, int invert);
 void drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert);
+void drw_colored_st(Drw *drw, int x, int y, unsigned int w, unsigned int h, char text[][256], const unsigned long *color, const char *ptext);
 
 /* Map functions */
 void drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h);
diff --git a/dwm.c b/dwm.c
index ffc8864..79ebbb4 100644
--- a/dwm.c
+++ b/dwm.c
@@ -232,6 +232,7 @@ static int xerror(Display *dpy, XErrorEvent *ee);
 static int xerrordummy(Display *dpy, XErrorEvent *ee);
 static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
+static void parsestatus(char *text, unsigned long *color_queue, char tokens[][256]);
 
 /* variables */
 static const char broken[] = "broken";
@@ -691,54 +692,103 @@ dirtomon(int dir) {
 }
 
 void
-drawbar(Monitor *m) {
-	int x, xx, w;
-	unsigned int i, occ = 0, urg = 0;
-	Client *c;
+parsestatus(char *text, unsigned long *color_queue, char tokens[][256]) {
+
+  char *copy = strdup(text);
+  char cleanBuf[strlen(text)];
+  memset(cleanBuf, 0, strlen(cleanBuf));
+  char *delim = "\x01\x02\x03\x04";
+  char *res = strtok(copy, delim);
+  strcat(tokens[0], res);
+  strcat(cleanBuf, res);
+  int i = 1;
+  int c = 0;
+
+  while (res) {
+
+    /* Figure out what delimiter was used */
+    // Thanks to http://stackoverflow.com/a/12460511/1612432
+    char deli = text[res - copy + strlen(res)];
+    if (deli == '\x01')
+      color_queue[c] = colors[0];
+    else if (deli == '\x02')
+      color_queue[c] = colors[1];
+    else if (deli == '\x03')
+      color_queue[c] = colors[2];
+    else if (deli == '\x04')
+      color_queue[c] = colors[3];
+    else
+      color_queue[c] = 0xff0000;
+    c++;
+    res = strtok(0, delim);
+    if (res){
+      strcat(tokens[i++], res);
+      strcat(cleanBuf, res);
+    }
+  }
+  free(copy);
+  strncpy(text, cleanBuf, strlen(cleanBuf));
+  text[strlen(cleanBuf)] = '\0';
+}
 
-	for(c = m->clients; c; c = c->next) {
-		occ |= c->tags;
-		if(c->isurgent)
-			urg |= c->tags;
-	}
-	x = 0;
-	for(i = 0; i < LENGTH(tags); i++) {
-		w = TEXTW(tags[i]);
-		drw_setscheme(drw, m->tagset[m->seltags] & 1 << i ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
-		drw_text(drw, x, 0, w, bh, tags[i], urg & 1 << i);
-		drw_rect(drw, x, 0, w, bh, m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-		           occ & 1 << i, urg & 1 << i);
-		x += w;
-	}
-	w = blw = TEXTW(m->ltsymbol);
-	drw_setscheme(drw, &scheme[SchemeNorm]);
-	drw_text(drw, x, 0, w, bh, m->ltsymbol, 0);
-	x += w;
-	xx = x;
-	if(m == selmon) { /* status is only drawn on selected monitor */
-		w = TEXTW(stext);
-		x = m->ww - w;
-		if(x < xx) {
-			x = xx;
-			w = m->ww - xx;
-		}
-		drw_text(drw, x, 0, w, bh, stext, 0);
-	}
-	else
-		x = m->ww;
-	if((w = x - xx) > bh) {
-		x = xx;
-		if(m->sel) {
-			drw_setscheme(drw, m == selmon ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, m->sel->name, 0);
-			drw_rect(drw, x, 0, w, bh, m->sel->isfixed, m->sel->isfloating, 0);
-		}
-		else {
-			drw_setscheme(drw, &scheme[SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, NULL, 0);
-		}
-	}
-	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+void
+drawbar(Monitor *m) {
+  int x, xx, w;
+  unsigned int i, occ = 0, urg = 0;
+  Client *c;
+
+  for(c = m->clients; c; c = c->next) {
+    occ |= c->tags;
+    if(c->isurgent)
+      urg |= c->tags;
+  }
+  x = 0;
+  for(i = 0; i < LENGTH(tags); i++) {
+    w = TEXTW(tags[i]);
+    drw_setscheme(drw, m->tagset[m->seltags] & 1 << i ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
+    drw_text(drw, x, 0, w, bh, tags[i], urg & 1 << i);
+    drw_rect(drw, x, 0, w, bh, m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+               occ & 1 << i, urg & 1 << i);
+    x += w;
+  }
+  w = blw = TEXTW(m->ltsymbol);
+  drw_setscheme(drw, &scheme[SchemeNorm]);
+  drw_text(drw, x, 0, w, bh, m->ltsymbol, 0);
+  x += w;
+  xx = x;
+  if(m == selmon) { /* status is only drawn on selected monitor */
+    unsigned long color_queue[50];
+    memset(color_queue, 0, sizeof(unsigned long) * 50);
+    char tokens[256][256];
+
+    for (int i = 0; i < 256; i++)
+      memset(tokens[i], 0, sizeof(char) * 256);
+
+    parsestatus(stext, color_queue, tokens);
+
+    w = TEXTW(stext);
+    x = m->ww - w;
+    if(x < xx) {
+      x = xx;
+      w = m->ww - xx;
+    }
+    drw_colored_st(drw, x, 0, w, bh, tokens, color_queue, stext);
+  }
+  else
+    x = m->ww;
+  if((w = x - xx) > bh) {
+    x = xx;
+    if(m->sel) {
+      drw_setscheme(drw, m == selmon ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
+      drw_text(drw, x, 0, w, bh, m->sel->name, 0);
+      drw_rect(drw, x, 0, w, bh, m->sel->isfixed, m->sel->isfloating, 0);
+    }
+    else {
+      drw_setscheme(drw, &scheme[SchemeNorm]);
+      drw_text(drw, x, 0, w, bh, NULL, 0);
+    }
+  }
+  drw_map(drw, m->barwin, 0, 0, m->ww, bh);
 }
 
 void
@@ -1226,7 +1276,7 @@ propertynotify(XEvent *e) {
 
 void
 quit(const Arg *arg) {
-	running = False;
+  running = False;
 }
 
 Monitor *
